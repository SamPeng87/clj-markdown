(ns clj-markdown.core  (:use [clojure.java.io])  (:use clj-markdown.token)  (:use clj-markdown.tags)  (:use clj-markdown.funcs)  (:use clj-markdown.inline)  (:import (clj_markdown.tags Link NewLine Code Heading Paragraph Table Html Text Lists Hr Blockquote)))(defn executeTranslate  "将文本解析成内部数据结构"  [src]  (token src true false))(defn changeWrap  "统一换行、空格以及tab"  [string]  (-> string      (clojure.string/replace #"\r\n|\r" "\n")      (clojure.string/replace #"\t" "    ")      (clojure.string/replace #"\u00a0", " ")      (clojure.string/replace #"\u2424" "\n")))(defmulti parseItem          (fn [item links] (type item))          :default nil)(defmethod parseItem NewLine  [item links]  "")(defmethod parseItem Hr  [item links]  (hr))(defmethod parseItem Code  [item links]  (code    (escape (.lines item))    (.lang item)))(defmethod parseItem Heading  [item links]  (h (.depth item)     (inline (.head item) links false)))(defmethod parseItem Paragraph  [item links]  (p (inline (.body item) links false)))(defmethod parseItem Blockquote  [item links]  (blockquote (loop [s (.body item) r nil]                (let [firstItem (first s)]                  (if (nil? firstItem)                    r                    (reduce (next s) (str r (parseItem firstItem links))))))))(defn parseListItem  [body links]  (loop [s body r nil]    (let [firstItem (first s)]      (if (nil? firstItem)        [r s]        (if (or (= firstItem "itemStart") (= firstItem "looseItemStart"))          (recur (next s) (str r nil))          (if (= firstItem "itemEnd")            [r (next s)]            (recur (next s) (str r (parseItem firstItem links)))))))))(defn parseListValue [body links]  (loop [s body r nil]    (let [firstItem (first s)]      (if (nil? firstItem)        r        (let [[liItem nextStart] (parseListItem s links)]          (recur nextStart (str r (li liItem))))))))(defmethod parseItem Lists  [item links]  (let [order (.order item)        listValue (parseListValue (.body item) links)]    (if order      (ol listValue)      (ul listValue))))(defn- parseTableHeader  [headers align links]  (tablerow (loop [s headers, r nil, i 0]    (let [firstItem (first s)]      (if (nil? firstItem)        r        (recur (next s)               (str r                    (tablecell                      (inline firstItem links false)                      {:header true                       :align  (get align i)}))               (inc i))))    )))(defn- parseTableCell  [cells aligns links]  (loop [s cells, r nil]    (let [firstItem (first s)]      (if (nil? firstItem)        r        (recur (next s)               (tablerow (str r (loop [cell firstItem, cellsResult nil, i 0]                                  (let [firstCellItem (first cell)]                                    (if (nil? firstCellItem)                                      cellsResult                                      (recur (next cell)                                             (str cellsResult                                                  (tablecell                                                    (inline firstCellItem links false)                                                    {:header false :align (get aligns i)}))                                             (inc i))))))))))))(defmethod parseItem Table  [item links]  (table    (parseTableHeader (.headers item) (.aligns item) links)    (parseTableCell (.cells item) (.aligns item) links)))(defmethod parseItem Html  [item links]  (let [body (if (not (.pre item))               (inline (.body item) links false)               (.body item))]    (html body)))(defmethod parseItem Text  [item links]  (inline (.body item) links false))(defn parseItems  [structs links]  (loop [s structs r ""]    (let [first (first s)]      (if (nil? first)        r        (let [result (parseItem first links)]          (recur (next s) (str r result)))        ))))(defn joinStrings  "最后将html队列拼接起来"  [results]  (let [group (group-by #(instance? Link %) results)        links (group true)        structs (group false)]    (parseItems structs links)))(defn parseString  "通过字符串解析markdown文件"  [string & settings]  (->    string    (changeWrap)    (executeTranslate)    (joinStrings)))(defn parseFile  "通过文件解析markdown文[件"  [filepath & config]  (let [fileread (slurp filepath :encoding "utf-8")]    (parseString fileread (when config (apply hash-map config)))))